{
  "features": [
    {
      "id": "position1",
      "name": "Short Word",
      "displayName": "Short Word",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires word input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "consMid",
      "name": "3 LETTER WORD",
      "displayName": "3 LETTER WORD",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires word input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "consMid2",
      "name": "Cons MID",
      "displayName": "Cons MID",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires word input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "vowel",
      "name": "Vowel",
      "displayName": "Vowel",
      "requiresParam": true,
      "analyzeFunction": "const vowels = new Set('aeiou'); const results = []; vowels.forEach(v => { const yes = wordlist.filter(w => w.toLowerCase().includes(v)); const no = wordlist.filter(w => !w.toLowerCase().includes(v)); results.push({ param: v.toUpperCase() + ' - YES', wordsLeft: yes.length, percentFiltered: 100 * (1 - yes.length / totalWords) }); results.push({ param: v.toUpperCase() + ' - NO', wordsLeft: no.length, percentFiltered: 100 * (1 - no.length / totalWords) }); }); return results;"
    },
    {
      "id": "vowelPos",
      "name": "VOWEL POS",
      "displayName": "VOWEL POS",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires vowel and section input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "o",
      "name": "O?",
      "displayName": "O?",
      "requiresParam": false,
      "analyzeFunction": "const hasO = wordlist.filter(w => w.toUpperCase().includes('O')); const noO = wordlist.filter(w => !w.toUpperCase().includes('O')); return [{ param: 'YES', wordsLeft: hasO.length, percentFiltered: 100 * (1 - hasO.length / totalWords) }, { param: 'NO', wordsLeft: noO.length, percentFiltered: 100 * (1 - noO.length / totalWords) }];"
    },
    {
      "id": "lexicon",
      "name": "Curved Pos.",
      "displayName": "Curved Pos.",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires position input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "eee",
      "name": "EEE?",
      "displayName": "EEE?",
      "requiresParam": false,
      "analyzeFunction": "const e = wordlist.filter(w => w.length >= 2 && w[1].toUpperCase() === 'E'); const yesLetters = new Set(['B', 'C', 'D', 'G', 'P', 'T', 'V', 'Z']); const yes = wordlist.filter(w => w.length >= 2 && yesLetters.has(w[1].toUpperCase())); const no = wordlist.filter(w => w.length >= 2 && !yesLetters.has(w[1].toUpperCase()) && w[1].toUpperCase() !== 'E'); return [{ param: 'E', wordsLeft: e.length, percentFiltered: 100 * (1 - e.length / totalWords) }, { param: 'YES', wordsLeft: yes.length, percentFiltered: 100 * (1 - yes.length / totalWords) }, { param: 'NO', wordsLeft: no.length, percentFiltered: 100 * (1 - no.length / totalWords) }];"
    },
    {
      "id": "eeeFirst",
      "name": "EEEFIRST",
      "displayName": "EEEFIRST",
      "requiresParam": false,
      "analyzeFunction": "const e = wordlist.filter(w => w.length >= 1 && w[0].toUpperCase() === 'E'); const yesLetters = new Set(['B', 'C', 'D', 'G', 'P', 'T', 'V', 'Z']); const yes = wordlist.filter(w => w.length >= 1 && yesLetters.has(w[0].toUpperCase())); const no = wordlist.filter(w => w.length >= 1 && !yesLetters.has(w[0].toUpperCase()) && w[0].toUpperCase() !== 'E'); return [{ param: 'E', wordsLeft: e.length, percentFiltered: 100 * (1 - e.length / totalWords) }, { param: 'YES', wordsLeft: yes.length, percentFiltered: 100 * (1 - yes.length / totalWords) }, { param: 'NO', wordsLeft: no.length, percentFiltered: 100 * (1 - no.length / totalWords) }];"
    },
    {
      "id": "originalLex",
      "name": "Lexicon",
      "displayName": "Lexicon",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires word input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "consonant",
      "name": "Cons. Together",
      "displayName": "Cons. Together",
      "requiresParam": false,
      "analyzeFunction": "const vowels = new Set('aeiou'); const hasConsTogether = wordlist.filter(w => { for (let i = 0; i < w.length - 1; i++) { if (!vowels.has(w[i].toLowerCase()) && !vowels.has(w[i+1].toLowerCase())) return true; } return false; }); const noConsTogether = wordlist.filter(w => { for (let i = 0; i < w.length - 1; i++) { if (!vowels.has(w[i].toLowerCase()) && !vowels.has(w[i+1].toLowerCase())) return false; } return true; }); return [{ param: 'YES', wordsLeft: hasConsTogether.length, percentFiltered: 100 * (1 - hasConsTogether.length / totalWords) }, { param: 'NO', wordsLeft: noConsTogether.length, percentFiltered: 100 * (1 - noConsTogether.length / totalWords) }];"
    },
    {
      "id": "colour3",
      "name": "Colour3",
      "displayName": "Colour3",
      "requiresParam": false,
      "analyzeFunction": "const colors = new Set(['r','e','d','b','l','u','e','g','r','e','e','n','y','e','l','l','o','w','o','r','a','n','g','e','p','u','r','p','l','e','p','i','n','k','b','r','o','w','n','b','l','a','c','k','w','h','i','t','e','g','r','a','y','g','r','e','y','c','y','a','n','m','a','g','e','n','t','a']); const yes = wordlist.filter(w => w.length >= 3 && colors.has(w[2].toLowerCase())); return [{ param: 'YES', wordsLeft: yes.length, percentFiltered: 100 * (1 - yes.length / totalWords) }];"
    },
    {
      "id": "length",
      "name": "LENGTH",
      "displayName": "LENGTH",
      "requiresParam": true,
      "analyzeFunction": "const lengths = {}; wordlist.forEach(w => { const len = w.length; lengths[len] = (lengths[len] || 0) + 1; }); return Object.keys(lengths).sort((a, b) => parseInt(a) - parseInt(b)).map(len => { const filtered = wordlist.filter(w => w.length === parseInt(len)); return { param: len + ' letters', wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }; });"
    },
    {
      "id": "mostFrequent",
      "name": "MOST FREQUENT",
      "displayName": "MOST FREQUENT",
      "requiresParam": false,
      "analyzeFunction": "const letterCounts = {}; wordlist.forEach(w => { w.toUpperCase().split('').forEach(c => { if (c >= 'A' && c <= 'Z') letterCounts[c] = (letterCounts[c] || 0) + 1; }); }); const sorted = Object.entries(letterCounts).sort((a, b) => b[1] - a[1]); const mostFreq = sorted[0][0]; const hasLetter = wordlist.filter(w => w.toUpperCase().includes(mostFreq)); const noLetter = wordlist.filter(w => !w.toUpperCase().includes(mostFreq)); return [{ param: mostFreq + ' - YES', wordsLeft: hasLetter.length, percentFiltered: 100 * (1 - hasLetter.length / totalWords) }, { param: mostFreq + ' - NO', wordsLeft: noLetter.length, percentFiltered: 100 * (1 - noLetter.length / totalWords) }];"
    },
    {
      "id": "leastFrequent",
      "name": "LEAST FREQUENT",
      "displayName": "LEAST FREQUENT",
      "requiresParam": false,
      "analyzeFunction": "const letterCounts = {}; wordlist.forEach(w => { w.toUpperCase().split('').forEach(c => { if (c >= 'A' && c <= 'Z') letterCounts[c] = (letterCounts[c] || 0) + 1; }); }); const sorted = Object.entries(letterCounts).sort((a, b) => a[1] - b[1]); const leastFreq = sorted[0][0]; const hasLetter = wordlist.filter(w => w.toUpperCase().includes(leastFreq)); const noLetter = wordlist.filter(w => !w.toUpperCase().includes(leastFreq)); return [{ param: leastFreq + ' - YES', wordsLeft: hasLetter.length, percentFiltered: 100 * (1 - hasLetter.length / totalWords) }, { param: leastFreq + ' - NO', wordsLeft: noLetter.length, percentFiltered: 100 * (1 - noLetter.length / totalWords) }];"
    },
    {
      "id": "notIn",
      "name": "NOT IN",
      "displayName": "NOT IN",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires letters input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "abcde",
      "name": "ABCDE",
      "displayName": "ABCDE",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const letters = ['A','B','C','D','E']; for (let i = 0; i < Math.pow(2, 5); i++) { const selected = []; letters.forEach((l, idx) => { if (i & (1 << idx)) selected.push(l); }); if (selected.length === 0) continue; const filtered = wordlist.filter(w => { const wUpper = w.toUpperCase(); const selectedUpper = selected.map(l => l.toUpperCase()); for (const letter of selectedUpper) { if (!wUpper.includes(letter)) return false; } for (const letter of letters) { if (!selectedUpper.includes(letter) && wUpper.includes(letter)) return false; } return true; }); results.push({ param: selected.join(','), wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }); } return results;"
    },
    {
      "id": "abc",
      "name": "ABC",
      "displayName": "ABC",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const letters = ['A','B','C']; for (let i = 0; i < Math.pow(2, 3); i++) { const selected = []; letters.forEach((l, idx) => { if (i & (1 << idx)) selected.push(l); }); if (selected.length === 0) continue; const filtered = wordlist.filter(w => { const wUpper = w.toUpperCase(); const selectedUpper = selected.map(l => l.toUpperCase()); for (const letter of selectedUpper) { if (!wUpper.includes(letter)) return false; } for (const letter of letters) { if (!selectedUpper.includes(letter) && wUpper.includes(letter)) return false; } return true; }); results.push({ param: selected.join(','), wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }); } return results;"
    },
    {
      "id": "findEee",
      "name": "FIND-EEE",
      "displayName": "FIND-EEE",
      "requiresParam": false,
      "analyzeFunction": "const letters = ['B','C','D','E','G','P','T','V','Z']; const results = []; letters.forEach(letter => { const hasLetter = wordlist.filter(w => w.toUpperCase().includes(letter)); results.push({ param: letter, wordsLeft: hasLetter.length, percentFiltered: 100 * (1 - hasLetter.length / totalWords) }); }); return results;"
    },
    {
      "id": "positionCons",
      "name": "POSITION-CONS",
      "displayName": "POSITION-CONS",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires position, letters, and count input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "firstCurved",
      "name": "FIRST CURVED",
      "displayName": "FIRST CURVED",
      "requiresParam": false,
      "analyzeFunction": "const curvedLetters = new Set(['B','C','D','G','J','O','P','Q','R','S','U']); const results = []; for (let pos = 1; pos <= 8; pos++) { const filtered = wordlist.filter(w => { const upperWord = w.toUpperCase(); if (upperWord.length <= pos - 1) return false; for (let i = 0; i < pos - 1; i++) { if (curvedLetters.has(upperWord[i])) return false; } return curvedLetters.has(upperWord[pos - 1]); }); results.push({ param: 'Position ' + pos, wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }); } return results;"
    },
    {
      "id": "pin",
      "name": "PIN",
      "displayName": "PIN",
      "requiresParam": true,
      "analyzeFunction": "return [{ param: 'Requires words and code input', wordsLeft: wordlist.length, percentFiltered: 0 }];"
    },
    {
      "id": "pianoForte",
      "name": "PIANO FORTE",
      "displayName": "PIANO FORTE",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const letters = ['A','B','C','D','E','F','G']; const pressedLetters = new Set(letters); for (let len = 1; len <= 4; len++) { const sequences = []; function generateSequences(seq, remaining) { if (seq.length === len) { sequences.push([...seq]); return; } remaining.forEach(letter => { generateSequences([...seq, letter], remaining); }); } generateSequences([], letters); sequences.forEach(sequence => { const filtered = wordlist.filter(w => { const wUpper = w.toUpperCase(); const wordPressedSequence = wUpper.split('').filter(char => ['A','B','C','D','E','F','G'].includes(char)); if (wordPressedSequence.length !== sequence.length) return false; for (let i = 0; i < sequence.length; i++) { if (wordPressedSequence[i] !== sequence[i]) return false; } const unpressedLetters = letters.filter(l => !new Set(sequence).has(l)); for (const letter of unpressedLetters) { if (wUpper.includes(letter)) return false; } return true; }); if (filtered.length > 0) { results.push({ param: sequence.join(''), wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }); } }); } return results.slice(0, 50);"
    },
    {
      "id": "pianoPiano",
      "name": "PIANO PIANO",
      "displayName": "PIANO PIANO",
      "requiresParam": false,
      "analyzeFunction": "const results = []; for (let count = 1; count <= 7; count++) { const filtered = wordlist.filter(w => { const wUpper = w.toUpperCase(); const agLetters = wUpper.split('').filter(char => ['A','B','C','D','E','F','G'].includes(char)); return agLetters.length === count; }); results.push({ param: count.toString(), wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }); } return results;"
    },
    {
      "id": "t9Length",
      "name": "LENGTH",
      "displayName": "LENGTH",
      "requiresParam": true,
      "analyzeFunction": "const results = []; const t9Map = new Map(); const t9Mapping = {'A':'2','B':'2','C':'2','D':'3','E':'3','F':'3','G':'4','H':'4','I':'4','J':'5','K':'5','L':'5','M':'6','N':'6','O':'6','P':'7','Q':'7','R':'7','S':'7','T':'8','U':'8','V':'8','W':'9','X':'9','Y':'9','Z':'9'}; wordlist.forEach(w => { const t9 = w.toUpperCase().split('').map(c => t9Mapping[c] || '').join(''); t9Map.set(w, t9); }); const lengths = {}; wordlist.forEach(w => { const len = t9Map.get(w).length; lengths[len] = (lengths[len] || 0) + 1; }); return Object.keys(lengths).sort((a, b) => parseInt(a) - parseInt(b)).map(len => { const filtered = wordlist.filter(w => t9Map.get(w).length === parseInt(len)); return { param: len + ' digits', wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }; });"
    },
    {
      "id": "t9LastTwo",
      "name": "LAST TWO",
      "displayName": "LAST TWO",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const t9Map = new Map(); const t9Mapping = {'A':'2','B':'2','C':'2','D':'3','E':'3','F':'3','G':'4','H':'4','I':'4','J':'5','K':'5','L':'5','M':'6','N':'6','O':'6','P':'7','Q':'7','R':'7','S':'7','T':'8','U':'8','V':'8','W':'9','X':'9','Y':'9','Z':'9'}; wordlist.forEach(w => { const t9 = w.toUpperCase().split('').map(c => t9Mapping[c] || '').join(''); t9Map.set(w, t9); }); const lastTwoMap = {}; wordlist.forEach(w => { const t9 = t9Map.get(w); if (t9.length >= 2) { const lastTwo = t9.slice(-2); lastTwoMap[lastTwo] = (lastTwoMap[lastTwo] || 0) + 1; } }); return Object.keys(lastTwoMap).sort().map(lastTwo => { const filtered = wordlist.filter(w => { const t9 = t9Map.get(w); return t9.length >= 2 && t9.slice(-2) === lastTwo; }); return { param: lastTwo, wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }; });"
    },
    {
      "id": "t9OneLie",
      "name": "1 LIE (L4)",
      "displayName": "1 LIE (L4)",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const t9Map = new Map(); const t9Mapping = {'A':'2','B':'2','C':'2','D':'3','E':'3','F':'3','G':'4','H':'4','I':'4','J':'5','K':'5','L':'5','M':'6','N':'6','O':'6','P':'7','Q':'7','R':'7','S':'7','T':'8','U':'8','V':'8','W':'9','X':'9','Y':'9','Z':'9'}; wordlist.forEach(w => { const t9 = w.toUpperCase().split('').map(c => t9Mapping[c] || '').join(''); t9Map.set(w, t9); }); const patterns = {}; for (let d1 = 2; d1 <= 9; d1++) { for (let d2 = 2; d2 <= 9; d2++) { for (let d3 = 2; d3 <= 9; d3++) { for (let d4 = 2; d4 <= 9; d4++) { const pattern = d1 + '' + d2 + '' + d3 + '' + d4; const filtered = wordlist.filter(w => { const t9 = t9Map.get(w); if (t9.length < 4) return false; const lastFour = t9.slice(-4); const lastFourDigits = lastFour.split(''); const digits = pattern.split(''); if ((lastFourDigits[1] === digits[1] && lastFourDigits[2] === digits[2] && lastFourDigits[3] === digits[3] && lastFourDigits[0] !== digits[0]) || (lastFourDigits[0] === digits[0] && lastFourDigits[2] === digits[2] && lastFourDigits[3] === digits[3] && lastFourDigits[1] !== digits[1]) || (lastFourDigits[0] === digits[0] && lastFourDigits[1] === digits[1] && lastFourDigits[3] === digits[3] && lastFourDigits[2] !== digits[2]) || (lastFourDigits[0] === digits[0] && lastFourDigits[1] === digits[1] && lastFourDigits[2] === digits[2] && lastFourDigits[3] !== digits[3])) { return true; } return false; }); if (filtered.length > 0) { patterns[pattern] = filtered.length; } } } } } return Object.keys(patterns).sort().slice(0, 50).map(pattern => ({ param: pattern, wordsLeft: patterns[pattern], percentFiltered: 100 * (1 - patterns[pattern] / totalWords) }));"
    },
    {
      "id": "t9Repeat",
      "name": "Repeat?",
      "displayName": "Repeat?",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const t9Map = new Map(); const t9Mapping = {'A':'2','B':'2','C':'2','D':'3','E':'3','F':'3','G':'4','H':'4','I':'4','J':'5','K':'5','L':'5','M':'6','N':'6','O':'6','P':'7','Q':'7','R':'7','S':'7','T':'8','U':'8','V':'8','W':'9','X':'9','Y':'9','Z':'9'}; wordlist.forEach(w => { const t9 = w.toUpperCase().split('').map(c => t9Mapping[c] || '').join(''); t9Map.set(w, t9); }); const hasRepeat = wordlist.filter(w => { const t9 = t9Map.get(w); for (let i = 0; i < t9.length - 1; i++) { if (t9[i] === t9[i + 1]) return true; } return false; }); const noRepeat = wordlist.filter(w => { const t9 = t9Map.get(w); for (let i = 0; i < t9.length - 1; i++) { if (t9[i] === t9[i + 1]) return false; } return true; }); return [{ param: 'Yes', wordsLeft: hasRepeat.length, percentFiltered: 100 * (1 - hasRepeat.length / totalWords) }, { param: 'No', wordsLeft: noRepeat.length, percentFiltered: 100 * (1 - noRepeat.length / totalWords) }];"
    },
    {
      "id": "t9Higher",
      "name": "Higher?",
      "displayName": "Higher?",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const t9Map = new Map(); const t9Mapping = {'A':'2','B':'2','C':'2','D':'3','E':'3','F':'3','G':'4','H':'4','I':'4','J':'5','K':'5','L':'5','M':'6','N':'6','O':'6','P':'7','Q':'7','R':'7','S':'7','T':'8','U':'8','V':'8','W':'9','X':'9','Y':'9','Z':'9'}; wordlist.forEach(w => { const t9 = w.toUpperCase().split('').map(c => t9Mapping[c] || '').join(''); t9Map.set(w, t9); }); const yes = wordlist.filter(w => { const t9 = t9Map.get(w); return t9.length >= 2 && parseInt(t9[1]) > parseInt(t9[0]); }); const no = wordlist.filter(w => { const t9 = t9Map.get(w); return t9.length >= 2 && parseInt(t9[1]) < parseInt(t9[0]); }); const same = wordlist.filter(w => { const t9 = t9Map.get(w); return t9.length >= 2 && parseInt(t9[1]) === parseInt(t9[0]); }); return [{ param: 'Yes', wordsLeft: yes.length, percentFiltered: 100 * (1 - yes.length / totalWords) }, { param: 'No', wordsLeft: no.length, percentFiltered: 100 * (1 - no.length / totalWords) }, { param: 'Same', wordsLeft: same.length, percentFiltered: 100 * (1 - same.length / totalWords) }];"
    },
    {
      "id": "t9OneTruth",
      "name": "1 TRUTH (F4)",
      "displayName": "1 TRUTH (F4)",
      "requiresParam": false,
      "analyzeFunction": "const results = []; const t9Map = new Map(); const t9Mapping = {'A':'2','B':'2','C':'2','D':'3','E':'3','F':'3','G':'4','H':'4','I':'4','J':'5','K':'5','L':'5','M':'6','N':'6','O':'6','P':'7','Q':'7','R':'7','S':'7','T':'8','U':'8','V':'8','W':'9','X':'9','Y':'9','Z':'9'}; wordlist.forEach(w => { const t9 = w.toUpperCase().split('').map(c => t9Mapping[c] || '').join(''); t9Map.set(w, t9); }); const patterns = {}; for (let d1 = 2; d1 <= 9; d1++) { for (let d2 = 2; d2 <= 9; d2++) { for (let d3 = 2; d3 <= 9; d3++) { for (let d4 = 2; d4 <= 9; d4++) { const pattern = d1 + '' + d2 + '' + d3 + '' + d4; const filtered = wordlist.filter(w => { const t9 = t9Map.get(w); if (t9.length < 4) return false; const firstFour = t9.slice(0, 4); const firstFourDigits = firstFour.split(''); const digits = pattern.split(''); if ((firstFourDigits[0] === digits[0] && firstFourDigits[1] !== digits[1] && firstFourDigits[2] !== digits[2] && firstFourDigits[3] !== digits[3]) || (firstFourDigits[0] !== digits[0] && firstFourDigits[1] === digits[1] && firstFourDigits[2] !== digits[2] && firstFourDigits[3] !== digits[3]) || (firstFourDigits[0] !== digits[0] && firstFourDigits[1] !== digits[1] && firstFourDigits[2] === digits[2] && firstFourDigits[3] !== digits[3]) || (firstFourDigits[0] !== digits[0] && firstFourDigits[1] !== digits[1] && firstFourDigits[2] !== digits[2] && firstFourDigits[3] === digits[3])) { return true; } return false; }); if (filtered.length > 0) { patterns[pattern] = filtered.length; } } } } } return Object.keys(patterns).sort().slice(0, 50).map(pattern => ({ param: pattern, wordsLeft: patterns[pattern], percentFiltered: 100 * (1 - patterns[pattern] / totalWords) }));"
    },
    {
      "id": "alphaNumeric",
      "name": "AlphaNumeric",
      "displayName": "AlphaNumeric",
      "requiresParam": false,
      "analyzeFunction": "const yes = wordlist.filter(w => { const wordLength = w.length; const upperWord = w.toUpperCase(); for (let i = 1; i <= 26 && i <= wordLength; i++) { const letter = String.fromCharCode(64 + i); if (wordLength === i && upperWord.includes(letter)) return true; } return false; }); const no = wordlist.filter(w => { const wordLength = w.length; const upperWord = w.toUpperCase(); for (let i = 1; i <= 26 && i <= wordLength; i++) { const letter = String.fromCharCode(64 + i); if (wordLength === i && upperWord.includes(letter)) return false; } return true; }); return [{ param: 'YES', wordsLeft: yes.length, percentFiltered: 100 * (1 - yes.length / totalWords) }, { param: 'NO', wordsLeft: no.length, percentFiltered: 100 * (1 - no.length / totalWords) }];"
    },
    {
      "id": "lettersAbove",
      "name": "Letters Above",
      "displayName": "Letters Above",
      "requiresParam": true,
      "analyzeFunction": "const results = []; for (let count = 0; count <= 26; count++) { const filtered = wordlist.filter(w => { const upperWord = w.toUpperCase(); const lettersInWord = new Set(upperWord.split('').filter(c => c >= 'A' && c <= 'Z')); for (const letter of lettersInWord) { const letterPos = letter.charCodeAt(0) - 64; let lettersBeforeCount = 0; for (let i = 1; i < letterPos; i++) { const beforeLetter = String.fromCharCode(64 + i); if (lettersInWord.has(beforeLetter)) lettersBeforeCount++; } if (lettersBeforeCount === count) return true; } return false; }); if (filtered.length > 0) { results.push({ param: count.toString(), wordsLeft: filtered.length, percentFiltered: 100 * (1 - filtered.length / totalWords) }); } } return results;"
    },
    {
      "id": "dictionaryAlpha",
      "name": "Dictionary (Alpha)",
      "displayName": "Dictionary (Alpha)",
      "requiresParam": false,
      "analyzeFunction": "const begin = wordlist.filter(w => { const first = w[0].toUpperCase().charCodeAt(0); return first >= 65 && first <= 77; }); const mid = wordlist.filter(w => { const first = w[0].toUpperCase().charCodeAt(0); return first >= 73 && first <= 84; }); const end = wordlist.filter(w => { const first = w[0].toUpperCase().charCodeAt(0); return first >= 78 && first <= 90; }); return [{ param: 'Beginning (A-M)', wordsLeft: begin.length, percentFiltered: 100 * (1 - begin.length / totalWords) }, { param: 'Middle (I-T)', wordsLeft: mid.length, percentFiltered: 100 * (1 - mid.length / totalWords) }, { param: 'End (N-Z)', wordsLeft: end.length, percentFiltered: 100 * (1 - end.length / totalWords) }];"
    },
    {
      "id": "smlLength",
      "name": "S/M/L (Length)",
      "displayName": "S/M/L (Length)",
      "requiresParam": false,
      "analyzeFunction": "const small = wordlist.filter(w => w.length >= 1 && w.length <= 6); const medium = wordlist.filter(w => w.length >= 5 && w.length <= 9); const long = wordlist.filter(w => w.length >= 7); return [{ param: 'Small (1-6)', wordsLeft: small.length, percentFiltered: 100 * (1 - small.length / totalWords) }, { param: 'Medium (5-9)', wordsLeft: medium.length, percentFiltered: 100 * (1 - medium.length / totalWords) }, { param: 'Long (7+)', wordsLeft: long.length, percentFiltered: 100 * (1 - long.length / totalWords) }];"
    }
  ]
}
